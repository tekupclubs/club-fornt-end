/* tslint:disable:no-host-metadata-property directive-selector */
import { Directive, EventEmitter, Inject, Input, Optional, Output } from '@angular/core';
import { NavigationCancel, NavigationEnd, NavigationError, Router } from '@angular/router';
import { DOCUMENT } from '@angular/common';
import { PageScrollService } from 'ngx-page-scroll-core';
import { filter, take } from 'rxjs/operators';
export class NgxPageScrollDirective {
    constructor(pageScrollService, router, document) {
        this.pageScrollService = pageScrollService;
        this.router = router;
        this.pageScrollAdjustHash = false;
        this.pageScrollFinish = new EventEmitter();
        this.document = document;
    }
    ngOnChanges(changes) {
        // Some inputs changed, reset the pageScrollInstance
        this.pageScrollInstance = undefined;
    }
    ngOnDestroy() {
        if (this.pageScrollInstance) {
            this.pageScrollService.stop(this.pageScrollInstance);
        }
    }
    getPageScrollTarget() {
        return this.pageScrollTarget || this.href || (this.fragment ? '#' + this.fragment : '');
    }
    generatePageScrollInstance() {
        if (this.pageScrollInstance === undefined || this.pageScrollInstance === null) {
            const options = {
                document: this.document,
                scrollTarget: this.getPageScrollTarget(),
            };
            if (this.pageScroll) {
                options.namespace = this.pageScroll;
            }
            if (this.pageScrollHorizontal !== undefined && this.pageScrollHorizontal !== null) {
                options.verticalScrolling = !this.pageScrollHorizontal;
            }
            if (this.pageScrollOffset !== undefined && this.pageScrollOffset !== null) {
                options.scrollOffset = this.pageScrollOffset;
            }
            if (this.pageScrollInterruptible !== undefined && this.pageScrollInterruptible !== null) {
                options.interruptible = this.pageScrollInterruptible;
            }
            if (this.pageScrollInView !== undefined && this.pageScrollInView !== null) {
                options.scrollInView = this.pageScrollInView;
            }
            if (this.pageScrollEasing) {
                options.easingLogic = this.pageScrollEasing;
            }
            if (this.pageScrollDuration !== undefined && this.pageScrollDuration !== null) {
                options.duration = this.pageScrollDuration;
            }
            if (this.pageScrollSpeed !== undefined && this.pageScrollSpeed !== null) {
                options.speed = this.pageScrollSpeed;
            }
            if (this.pageScrollFinish) {
                options.scrollFinishListener = this.pageScrollFinish;
            }
            this.pageScrollInstance = this.pageScrollService.create(options);
        }
        return this.pageScrollInstance;
    }
    pushRouterState() {
        if (this.pageScrollAdjustHash && typeof this.pageScrollInstance.pageScrollOptions.scrollTarget === 'string'
            && this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(0, 1) === '#') {
            // "Navigate" to the current route again and this time set the fragment/hash
            this.router.navigate([], {
                fragment: this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(1),
                queryParamsHandling: 'preserve',
            });
        }
    }
    scroll() {
        const pageScrollInstance = this.generatePageScrollInstance();
        this.pushRouterState();
        this.pageScrollService.start(pageScrollInstance);
    }
    handleClick(clickEvent) {
        if (this.routerLink && this.router !== null && this.router !== undefined) {
            let urlTree;
            if (typeof this.routerLink === 'string') {
                urlTree = this.router.parseUrl(this.routerLink);
            }
            else {
                urlTree = this.router.createUrlTree(this.routerLink);
            }
            if (!this.router.isActive(urlTree, true)) {
                // We need to navigate their first.
                // Navigation is handled by the routerLink directive so we only need to listen for route change
                this.router.events.pipe(filter(routerEvent => {
                    // We're only interested in successful navigations or when the navigation fails
                    return routerEvent instanceof NavigationEnd || routerEvent instanceof NavigationError
                        || routerEvent instanceof NavigationCancel;
                }), 
                // Consume only one event, automatically "unsubscribing" from the event stream afterwards
                take(1)).subscribe((routerEvent) => {
                    if (routerEvent instanceof NavigationEnd) {
                        // use a timeout to start scrolling as soon as the stack is cleared
                        setTimeout(() => {
                            this.scroll();
                        }, 0);
                    }
                });
                return false; // to preventDefault()
            }
        }
        this.scroll();
        return false; // to preventDefault()
    }
}
NgxPageScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pageScroll]',
                host: {
                    '(click)': 'handleClick($event)',
                },
            },] }
];
NgxPageScrollDirective.ctorParameters = () => [
    { type: PageScrollService },
    { type: Router, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
NgxPageScrollDirective.propDecorators = {
    routerLink: [{ type: Input }],
    href: [{ type: Input }],
    fragment: [{ type: Input }],
    pageScrollTarget: [{ type: Input }],
    pageScrollHorizontal: [{ type: Input }],
    pageScrollOffset: [{ type: Input }],
    pageScrollDuration: [{ type: Input }],
    pageScrollSpeed: [{ type: Input }],
    pageScrollEasing: [{ type: Input }],
    pageScrollInterruptible: [{ type: Input }],
    pageScrollInView: [{ type: Input }],
    pageScrollAdjustHash: [{ type: Input }],
    pageScroll: [{ type: Input }],
    pageScrollFinish: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXBhZ2Utc2Nyb2xsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1wYWdlLXNjcm9sbC9zcmMvbGliL25neC1wYWdlLXNjcm9sbC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUVBQWlFO0FBRWpFLE9BQU8sRUFDTCxTQUFTLEVBQ1QsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBR0wsUUFBUSxFQUNSLE1BQU0sRUFFUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQVcsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFM0MsT0FBTyxFQUFzRCxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzdHLE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFROUMsTUFBTSxPQUFPLHNCQUFzQjtJQStDakMsWUFBb0IsaUJBQW9DLEVBQXNCLE1BQWMsRUFBb0IsUUFBYTtRQUF6RyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQXNCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFYckYseUJBQW9CLEdBQUcsS0FBSyxDQUFDO1FBTXBDLHFCQUFnQixHQUEwQixJQUFJLFlBQVksRUFBVyxDQUFDO1FBTXBFLElBQUksQ0FBQyxRQUFRLEdBQUksUUFBcUIsQ0FBQztJQUN6QyxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLG9EQUFvRDtRQUNwRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDM0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJ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QztnQkFDL0MsQ0FBQyxDQUFDO2dCQUNGLHlGQUF5RjtnQkFDekYsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNSLENBQUMsU0FBUyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUU7b0JBQzFCLElBQUksV0FBVyxZQUFZLGFBQWEsRUFBRTt3QkFDeEMsbUVBQW1FO3dCQUNuRSxVQUFVLENBQUMsR0FBRyxFQUFFOzRCQUNkLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzt3QkFDaEIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO3FCQUNQO2dCQUNILENBQUMsQ0FBQyxDQUFDO2dCQUVILE9BQU8sS0FBSyxDQUFDLENBQUMsc0JBQXNCO2FBQ3JDO1NBQ0Y7UUFDRCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFZCxPQUFPLEtBQUssQ0FBQyxDQUFDLHNCQUFzQjtJQUN0QyxDQUFDOzs7WUFsS0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxjQUFjO2dCQUN4QixJQUFJLEVBQUU7b0JBQ0osU0FBUyxFQUFFLHFCQUFxQjtpQkFDakM7YUFDRjs7O1lBUjRELGlCQUFpQjtZQUhuQixNQUFNLHVCQTJESixRQUFROzRDQUE0QixNQUFNLFNBQUMsUUFBUTs7O3lCQTdDN0csS0FBSzttQkFHTCxLQUFLO3VCQUdMLEtBQUs7K0JBR0wsS0FBSzttQ0FHTCxLQUFLOytCQUdMLEtBQUs7aUNBR0wsS0FBSzs4QkFHTCxLQUFLOytCQUdMLEtBQUs7c0NBR0wsS0FBSzsrQkFHTCxLQUFLO21DQUdMLEtBQUs7eUJBR0wsS0FBSzsrQkFHTCxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGU6bm8taG9zdC1tZXRhZGF0YS1wcm9wZXJ0eSBkaXJlY3RpdmUtc2VsZWN0b3IgKi9cblxuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNhbmNlbCwgTmF2aWdhdGlvbkVuZCwgTmF2aWdhdGlvbkVycm9yLCBSb3V0ZXIsIFVybFRyZWUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBFYXNpbmdMb2dpYywgUGFnZVNjcm9sbEluc3RhbmNlLCBQYWdlU2Nyb2xsT3B0aW9ucywgUGFnZVNjcm9sbFNlcnZpY2UgfSBmcm9tICduZ3gtcGFnZS1zY3JvbGwtY29yZSc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1twYWdlU2Nyb2xsXScsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICdoYW5kbGVDbGljaygkZXZlbnQpJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTmd4UGFnZVNjcm9sbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICBASW5wdXQoKVxuICBwdWJsaWMgcm91dGVyTGluazogYW55O1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBocmVmOiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgcHVibGljIGZyYWdtZW50OiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgcHVibGljIHBhZ2VTY3JvbGxUYXJnZXQ6IHN0cmluZztcblxuICBASW5wdXQoKVxuICBwdWJsaWMgcGFnZVNjcm9sbEhvcml6b250YWw6IGJvb2xlYW47XG5cbiAgQElucHV0KClcbiAgcHVibGljIHBhZ2VTY3JvbGxPZmZzZXQ6IG51bWJlcjtcblxuICBASW5wdXQoKVxuICBwdWJsaWMgcGFnZVNjcm9sbER1cmF0aW9uOiBudW1iZXI7XG5cbiAgQElucHV0KClcbiAgcHVibGljIHBhZ2VTY3JvbGxTcGVlZDogbnVtYmVyO1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBwYWdlU2Nyb2xsRWFzaW5nOiBFYXNpbmdMb2dpYztcblxuICBASW5wdXQoKVxuICBwdWJsaWMgcGFnZVNjcm9sbEludGVycnVwdGlibGU6IGJvb2xlYW47XG5cbiAgQElucHV0KClcbiAgcHVibGljIHBhZ2VTY3JvbGxJblZpZXc6IGJvb2xlYW47XG5cbiAgQElucHV0KClcbiAgcHVibGljIHBhZ2VTY3JvbGxBZGp1c3RIYXNoID0gZmFsc2U7XG5cbiAgQElucHV0KClcbiAgcHVibGljIHBhZ2VTY3JvbGw6IHN0cmluZztcblxuICBAT3V0cHV0KClcbiAgcGFnZVNjcm9sbEZpbmlzaDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHByaXZhdGUgcGFnZVNjcm9sbEluc3RhbmNlOiBQYWdlU2Nyb2xsSW5zdGFuY2U7XG4gIHByaXZhdGUgZG9jdW1lbnQ6IERvY3VtZW50O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGFnZVNjcm9sbFNlcnZpY2U6IFBhZ2VTY3JvbGxTZXJ2aWNlLCBAT3B0aW9uYWwoKSBwcml2YXRlIHJvdXRlcjogUm91dGVyLCBASW5qZWN0KERPQ1VNRU5UKSBkb2N1bWVudDogYW55KSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IChkb2N1bWVudCBhcyBEb2N1bWVudCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgLy8gU29tZSBpbnB1dHMgY2hhbmdlZCwgcmVzZXQgdGhlIHBhZ2VTY3JvbGxJbnN0YW5jZVxuICAgIHRoaXMucGFnZVNjcm9sbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucGFnZVNjcm9sbEluc3RhbmNlKSB7XG4gICAgICB0aGlzLnBhZ2VTY3JvbGxTZXJ2aWNlLnN0b3AodGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGFnZVNjcm9sbFRhcmdldCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhZ2VTY3JvbGxUYXJnZXQgfHwgdGhpcy5ocmVmIHx8ICh0aGlzLmZyYWdtZW50ID8gJyMnICsgdGhpcy5mcmFnbWVudCA6ICcnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVQYWdlU2Nyb2xsSW5zdGFuY2UoKTogUGFnZVNjcm9sbEluc3RhbmNlIHtcbiAgICBpZiAodGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2UgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnBhZ2VTY3JvbGxJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3B0aW9uczogUGFnZVNjcm9sbE9wdGlvbnMgPSB7XG4gICAgICAgIGRvY3VtZW50OiB0aGlzLmRvY3VtZW50LFxuICAgICAgICBzY3JvbGxUYXJnZXQ6IHRoaXMuZ2V0UGFnZVNjcm9sbFRhcmdldCgpLFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMucGFnZVNjcm9sbCkge1xuICAgICAgICBvcHRpb25zLm5hbWVzcGFjZSA9IHRoaXMucGFnZVNjcm9sbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhZ2VTY3JvbGxIb3Jpem9udGFsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYWdlU2Nyb2xsSG9yaXpvbnRhbCAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnZlcnRpY2FsU2Nyb2xsaW5nID0gIXRoaXMucGFnZVNjcm9sbEhvcml6b250YWw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWdlU2Nyb2xsT2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYWdlU2Nyb2xsT2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuc2Nyb2xsT2Zmc2V0ID0gdGhpcy5wYWdlU2Nyb2xsT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFnZVNjcm9sbEludGVycnVwdGlibGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhZ2VTY3JvbGxJbnRlcnJ1cHRpYmxlICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuaW50ZXJydXB0aWJsZSA9IHRoaXMucGFnZVNjcm9sbEludGVycnVwdGlibGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWdlU2Nyb2xsSW5WaWV3ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYWdlU2Nyb2xsSW5WaWV3ICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuc2Nyb2xsSW5WaWV3ID0gdGhpcy5wYWdlU2Nyb2xsSW5WaWV3O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFnZVNjcm9sbEVhc2luZykge1xuICAgICAgICBvcHRpb25zLmVhc2luZ0xvZ2ljID0gdGhpcy5wYWdlU2Nyb2xsRWFzaW5nO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFnZVNjcm9sbER1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYWdlU2Nyb2xsRHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IHRoaXMucGFnZVNjcm9sbER1cmF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFnZVNjcm9sbFNwZWVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYWdlU2Nyb2xsU3BlZWQgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5zcGVlZCA9IHRoaXMucGFnZVNjcm9sbFNwZWVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFnZVNjcm9sbEZpbmlzaCkge1xuICAgICAgICBvcHRpb25zLnNjcm9sbEZpbmlzaExpc3RlbmVyID0gdGhpcy5wYWdlU2Nyb2xsRmluaXNoO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2UgPSB0aGlzLnBhZ2VTY3JvbGxTZXJ2aWNlLmNyZWF0ZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIHB1c2hSb3V0ZXJTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYWdlU2Nyb2xsQWRqdXN0SGFzaCAmJiB0eXBlb2YgdGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVGFyZ2V0ID09PSAnc3RyaW5nJ1xuICAgICAgJiYgKHRoaXMucGFnZVNjcm9sbEluc3RhbmNlLnBhZ2VTY3JvbGxPcHRpb25zLnNjcm9sbFRhcmdldCBhcyBzdHJpbmcpLnN1YnN0cigwLCAxKSA9PT0gJyMnKSB7XG4gICAgICAvLyBcIk5hdmlnYXRlXCIgdG8gdGhlIGN1cnJlbnQgcm91dGUgYWdhaW4gYW5kIHRoaXMgdGltZSBzZXQgdGhlIGZyYWdtZW50L2hhc2hcbiAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtdLCB7XG4gICAgICAgIGZyYWdtZW50OiAodGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVGFyZ2V0IGFzIHN0cmluZykuc3Vic3RyKDEpLFxuICAgICAgICBxdWVyeVBhcmFtc0hhbmRsaW5nOiAncHJlc2VydmUnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzY3JvbGwoKTogdm9pZCB7XG4gICAgY29uc3QgcGFnZVNjcm9sbEluc3RhbmNlID0gdGhpcy5nZW5lcmF0ZVBhZ2VTY3JvbGxJbnN0YW5jZSgpO1xuICAgIHRoaXMucHVzaFJvdXRlclN0YXRlKCk7XG4gICAgdGhpcy5wYWdlU2Nyb2xsU2VydmljZS5zdGFydChwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICB9XG5cbiAgcHVibGljIGhhbmRsZUNsaWNrKGNsaWNrRXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG4gICAgaWYgKHRoaXMucm91dGVyTGluayAmJiB0aGlzLnJvdXRlciAhPT0gbnVsbCAmJiB0aGlzLnJvdXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgdXJsVHJlZTogVXJsVHJlZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5yb3V0ZXJMaW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICB1cmxUcmVlID0gdGhpcy5yb3V0ZXIucGFyc2VVcmwodGhpcy5yb3V0ZXJMaW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFRyZWUgPSB0aGlzLnJvdXRlci5jcmVhdGVVcmxUcmVlKHRoaXMucm91dGVyTGluayk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIHRydWUpKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbmF2aWdhdGUgdGhlaXIgZmlyc3QuXG4gICAgICAgIC8vIE5hdmlnYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgcm91dGVyTGluayBkaXJlY3RpdmUgc28gd2Ugb25seSBuZWVkIHRvIGxpc3RlbiBmb3Igcm91dGUgY2hhbmdlXG4gICAgICAgIHRoaXMucm91dGVyLmV2ZW50cy5waXBlKGZpbHRlcihyb3V0ZXJFdmVudCA9PiB7XG4gICAgICAgICAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9ucyBvciB3aGVuIHRoZSBuYXZpZ2F0aW9uIGZhaWxzXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyRXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kIHx8IHJvdXRlckV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVycm9yXG4gICAgICAgICAgICAgIHx8IHJvdXRlckV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkNhbmNlbDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvLyBDb25zdW1lIG9ubHkgb25lIGV2ZW50LCBhdXRvbWF0aWNhbGx5IFwidW5zdWJzY3JpYmluZ1wiIGZyb20gdGhlIGV2ZW50IHN0cmVhbSBhZnRlcndhcmRzXG4gICAgICAgICAgdGFrZSgxKVxuICAgICAgICApLnN1YnNjcmliZSgocm91dGVyRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAocm91dGVyRXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSB7XG4gICAgICAgICAgICAvLyB1c2UgYSB0aW1lb3V0IHRvIHN0YXJ0IHNjcm9sbGluZyBhcyBzb29uIGFzIHRoZSBzdGFjayBpcyBjbGVhcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5zY3JvbGwoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB0byBwcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsKCk7XG5cbiAgICByZXR1cm4gZmFsc2U7IC8vIHRvIHByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuIl19